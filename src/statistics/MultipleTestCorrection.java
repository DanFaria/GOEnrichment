/******************************************************************************
* Corrects the p-values generated by Fisher's exact test due to the fact that *
* we are performing multiple tests in GO enrichment analysis.                 *
* Implements several strategies for multiple test correction (as listed in    *
* CorrectionOption): the very conservative Bonferroni correction; the less    *
* conservative FWER Bonferroni-Holm and Sidak corrections; the modification   *
* of the Sidak correction to account for positive dependence (SDA correction) *
* and the more permissive FDR Benjamini-Hochberg correction (which computes   *
* q-values rather than corrected p-values).                                   *
*                                                                             *
* @author Daniel Faria                                                        *
******************************************************************************/

package statistics;

import java.util.Set;

import ontology.AnnotationSet;
import main.GOEnrichment;

public class MultipleTestCorrection
{
	private GOEnrichment ea;
	private TestResult[] testByType;
	private CorrectionOption c;
	private AnnotationSet a;
	
	public MultipleTestCorrection()
	{
		ea = GOEnrichment.getInstance();
		testByType = ea.getResults();
		c = ea.getCorrectionOption();
		a = ea.getAnnotationSet();
	}
	
	public void correct()
	{
		if(c.equals(CorrectionOption.BONFERRONI))
		{
			for(int i = 0; i < 3; i++)
			{
				double family = testByType[i].getTerms().size();
				for(int go : testByType[i].getTerms())
				{
					double p = testByType[i].getPValue(go);
					double pCorr = Math.min(1, p * family);
					testByType[i].setCorrectedPValue(go, pCorr);
				}
			}
		}
		else if(c.equals(CorrectionOption.BONFERRONI_HOLM))
		{
			for(int i = 0; i < 3; i++)
			{
				int step = 0;
				double stepPValue = 0.0;
				double family = testByType[i].getTerms().size();
				for(int go : testByType[i].getTerms())
				{
					double p = testByType[i].getPValue(go);
					double pCorr = Math.min(1.0, Math.max(stepPValue, p * (family-step)));
					testByType[i].setCorrectedPValue(go, pCorr);
					step++;
					stepPValue = pCorr;
				}
			}
		}
		else if(c.equals(CorrectionOption.SIDAK))
		{
			for(int i = 0; i < 3; i++)
			{
				double family = testByType[i].getTerms().size();
				for(int go : testByType[i].getTerms())
				{
					double p = testByType[i].getPValue(go);
					double pCorr = 1 - Math.pow(1.0 - p, family);
					testByType[i].setCorrectedPValue(go, pCorr);
				}
			}
		}
		else if(c.equals(CorrectionOption.SDA))
		{
			for(int i = 0; i < 3; i++)
			{
				for(int go : testByType[i].getTerms())
				{
					double p = testByType[i].getPValue(go);
					double family = effectiveFamilySize(go,testByType[i].getTerms());
					double pCorr = 1 - Math.pow(1.0 - p, family);
					testByType[i].setCorrectedPValue(go, pCorr);
				}
			}
		}
		else if(c.equals(CorrectionOption.BENJAMINI_HOCHBERG))
		{
			for(int i = 0; i < 3; i++)
			{
				int step = 1;
				double stepPValue = 0.0;
				double family = testByType[i].getTerms().size();
				for(int go : testByType[i].getTerms())
				{
					double p = testByType[i].getPValue(go);
					double q = Math.min(1.0, Math.max(stepPValue, p*family/step));
					testByType[i].setCorrectedPValue(go, q);
					step++;
					stepPValue = q;
				}
			}
		}
	}
	
	//Computes the effective family size for the SDA correction
	private double effectiveFamilySize(int go, Set<Integer> family)
	{
		double corr = 0.0;
		for(int f : family)
			corr += a.correlation(go,f);
		corr /= family.size();
		return Math.pow(family.size(), 1-corr);
	}
}
